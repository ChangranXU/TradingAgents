"""Pydantic schemas for standardized LLM I/O in trading.

These schemas enforce the "strict schema + post-call validation" pattern described
in ArbiterOS ACF docs. They are designed to ensure consistent, validated JSON
outputs from LLM calls.

Usage:
    # Import schemas
    from llm_schemas import BullResearcherOutput, TraderDecisionOutput

    # Wire into LLM calls using with_structured_output
    structured_llm = llm.with_structured_output(BullResearcherOutput)
    result = structured_llm.invoke(prompt)
    # result is now a validated Pydantic object
    # Access via result.content (string) or result.field_name (typed)

Generated by ArbiterOS Migration Tool.
"""

from __future__ import annotations

from enum import Enum
from typing import List, Literal, Optional, Dict, Any

from pydantic import BaseModel, Field

from pydantic import BaseModel, Field
from enum import Enum
from typing import List, Optional

try:
    from langchain_core.messages import AIMessage
    _HAS_LANGCHAIN = True
except ImportError:
    _HAS_LANGCHAIN = False


# =============================================================================
# Schema-Function Mapping
# =============================================================================
# Maps agent function names to their output schema classes.
# Used by governed agent wrappers to wire schemas into LLM calls.

SCHEMA_FUNCTION_MAP: Dict[str, str] = {
    "bull_node": "BullResearcherOutput",
    "create_bull_researcher": "BullResearcherOutput",
    "bear_node": "BearResearcherOutput",
    "create_bear_researcher": "BearResearcherOutput",
    "trader_node": "TraderDecisionOutput",
    "create_trader": "TraderDecisionOutput",
    "risk_manager_node": "RiskManagerOutput",
    "create_risk_manager": "RiskManagerOutput",
    "research_manager_node": "ResearchManagerOutput",
    "create_research_manager": "ResearchManagerOutput",
}


def get_schema_for_function(func_name: str) -> type[BaseModel] | None:
    """Get the output schema class for a given function name.

    Args:
        func_name: Name of the agent function.

    Returns:
        The Pydantic schema class, or None if no mapping exists.
    """
    schema_name = SCHEMA_FUNCTION_MAP.get(func_name)
    if schema_name:
        return globals().get(schema_name)
    return None


# =============================================================================
# Output Schemas
# =============================================================================

class TradeDecision(str, Enum):
    """Enum representing possible trade decisions."""

    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"

class RiskLevel(str, Enum):
    """Enum representing risk levels for trading decisions."""

    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"

class BullResearcherOutput(BaseModel):
    """Output schema for the Bull Researcher agent, capturing bullish analysis and recommendations.

    Used by: bull_node, create_bull_researcher
    """

    bullish_trends: List[str] = Field(
        ...,
        description="List of identified bullish trends."
    )
    confidence: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Confidence score of the analysis (0.0-1.0)"
    )
    quality_score: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Quality assessment of the analysis (0.0-1.0)"
    )
    risk_level: float = Field(
        default=None,
        description="Risk level assessment (0.0-1.0, where 1.0 is highest risk)"
    )

    @property
    def content(self) -> str:
        """Convert structured output to content string for backward compatibility.
        
        This property allows existing code that accesses .content to work
        seamlessly with structured output.
        """
        return self.to_content()
    
    def to_message(self):
        """Convert to LangChain AIMessage for message list compatibility.
        
        Returns:
            AIMessage with formatted content, or self if langchain not available.
        """
        if _HAS_LANGCHAIN:
            return AIMessage(content=self.to_content())
        return self
    
    def to_content(self) -> str:
        """Convert the structured output to a formatted string.
        
        Returns:
            A formatted string representation suitable for messages and logs.
        """
        # Smart formatting based on field types and names
        parts = []
        data = self.model_dump()
        
        # Look for common "main content" fields first
        primary_fields = ['summary', 'rationale', 'content', 'report', 'report_markdown', 
                         'thesis', 'bull_thesis', 'bear_thesis', 'analysis_summary']
        
        # Add primary content fields first (if they exist)
        for field_name in primary_fields:
            if field_name in data and data[field_name]:
                parts.append(str(data[field_name]))
        
        # Then add other important fields
        for field_name, field_value in data.items():
            if field_name in primary_fields or field_value is None:
                continue
                
            # Format based on type
            if isinstance(field_value, list) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:**")
                for item in field_value:
                    parts.append(f"- {item}")
            elif isinstance(field_value, float):
                # Format percentages nicely
                if 'confidence' in field_name or 'probability' in field_name:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.1%}")
                else:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.2f}")
            elif isinstance(field_value, bool):
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {'Yes' if field_value else 'No'}")
            elif isinstance(field_value, str) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value}")
            elif hasattr(field_value, 'value'):  # Enum
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value.value}")
        
        return "\n".join(parts) if parts else str(data)

class BearResearcherOutput(BaseModel):
    """Output schema for the Bear Researcher agent, capturing bearish analysis and risks.

    Used by: bear_node, create_bear_researcher
    """

    bearish_trends: List[str] = Field(
        ...,
        description="List of identified bearish trends."
    )
    confidence: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Confidence score of the analysis (0.0-1.0)"
    )
    quality_score: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Quality assessment of the analysis (0.0-1.0)"
    )
    risk_level: float = Field(
        default=None,
        description="Risk level assessment (0.0-1.0, where 1.0 is highest risk)"
    )

    @property
    def content(self) -> str:
        """Convert structured output to content string for backward compatibility.
        
        This property allows existing code that accesses .content to work
        seamlessly with structured output.
        """
        return self.to_content()
    
    def to_message(self):
        """Convert to LangChain AIMessage for message list compatibility.
        
        Returns:
            AIMessage with formatted content, or self if langchain not available.
        """
        if _HAS_LANGCHAIN:
            return AIMessage(content=self.to_content())
        return self
    
    def to_content(self) -> str:
        """Convert the structured output to a formatted string.
        
        Returns:
            A formatted string representation suitable for messages and logs.
        """
        # Smart formatting based on field types and names
        parts = []
        data = self.model_dump()
        
        # Look for common "main content" fields first
        primary_fields = ['summary', 'rationale', 'content', 'report', 'report_markdown', 
                         'thesis', 'bull_thesis', 'bear_thesis', 'analysis_summary']
        
        # Add primary content fields first (if they exist)
        for field_name in primary_fields:
            if field_name in data and data[field_name]:
                parts.append(str(data[field_name]))
        
        # Then add other important fields
        for field_name, field_value in data.items():
            if field_name in primary_fields or field_value is None:
                continue
                
            # Format based on type
            if isinstance(field_value, list) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:**")
                for item in field_value:
                    parts.append(f"- {item}")
            elif isinstance(field_value, float):
                # Format percentages nicely
                if 'confidence' in field_name or 'probability' in field_name:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.1%}")
                else:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.2f}")
            elif isinstance(field_value, bool):
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {'Yes' if field_value else 'No'}")
            elif isinstance(field_value, str) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value}")
            elif hasattr(field_value, 'value'):  # Enum
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value.value}")
        
        return "\n".join(parts) if parts else str(data)

class TraderDecisionOutput(BaseModel):
    """Output schema for the Trader agent, capturing trade decisions and associated risk.

    Used by: trader_node, create_trader
    """

    trade_decision: TradeDecision = Field(
        ...,
        description="The trade decision made by the trader."
    )
    risk_level: Optional[RiskLevel] = Field(
        ...,
        description="Assessed risk level of the trade decision."
    )
    confidence: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Confidence in the trade decision (0.0-1.0)"
    )
    quality_score: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Quality assessment of the trade decision (0.0-1.0)"
    )

    @property
    def content(self) -> str:
        """Convert structured output to content string for backward compatibility.
        
        This property allows existing code that accesses .content to work
        seamlessly with structured output.
        """
        return self.to_content()
    
    def to_message(self):
        """Convert to LangChain AIMessage for message list compatibility.
        
        Returns:
            AIMessage with formatted content, or self if langchain not available.
        """
        if _HAS_LANGCHAIN:
            return AIMessage(content=self.to_content())
        return self
    
    def to_content(self) -> str:
        """Convert the structured output to a formatted string.
        
        Returns:
            A formatted string representation suitable for messages and logs.
        """
        # Smart formatting based on field types and names
        parts = []
        data = self.model_dump()
        
        # Look for common "main content" fields first
        primary_fields = ['summary', 'rationale', 'content', 'report', 'report_markdown', 
                         'thesis', 'bull_thesis', 'bear_thesis', 'analysis_summary']
        
        # Add primary content fields first (if they exist)
        for field_name in primary_fields:
            if field_name in data and data[field_name]:
                parts.append(str(data[field_name]))
        
        # Then add other important fields
        for field_name, field_value in data.items():
            if field_name in primary_fields or field_value is None:
                continue
                
            # Format based on type
            if isinstance(field_value, list) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:**")
                for item in field_value:
                    parts.append(f"- {item}")
            elif isinstance(field_value, float):
                # Format percentages nicely
                if 'confidence' in field_name or 'probability' in field_name:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.1%}")
                else:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.2f}")
            elif isinstance(field_value, bool):
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {'Yes' if field_value else 'No'}")
            elif isinstance(field_value, str) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value}")
            elif hasattr(field_value, 'value'):  # Enum
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value.value}")
        
        return "\n".join(parts) if parts else str(data)

class RiskManagerOutput(BaseModel):
    """Output schema for the Risk Manager agent, capturing risk assessments and recommendations.

    Used by: risk_manager_node, create_risk_manager
    """

    risk_assessment: str = Field(
        ...,
        description="Detailed risk assessment report."
    )
    risk_level: Optional[RiskLevel] = Field(
        ...,
        description="Assessed risk level of the situation."
    )
    confidence: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Confidence in the risk assessment (0.0-1.0)"
    )
    quality_score: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Quality assessment of the risk analysis (0.0-1.0)"
    )

    @property
    def content(self) -> str:
        """Convert structured output to content string for backward compatibility.
        
        This property allows existing code that accesses .content to work
        seamlessly with structured output.
        """
        return self.to_content()
    
    def to_message(self):
        """Convert to LangChain AIMessage for message list compatibility.
        
        Returns:
            AIMessage with formatted content, or self if langchain not available.
        """
        if _HAS_LANGCHAIN:
            return AIMessage(content=self.to_content())
        return self
    
    def to_content(self) -> str:
        """Convert the structured output to a formatted string.
        
        Returns:
            A formatted string representation suitable for messages and logs.
        """
        # Smart formatting based on field types and names
        parts = []
        data = self.model_dump()
        
        # Look for common "main content" fields first
        primary_fields = ['summary', 'rationale', 'content', 'report', 'report_markdown', 
                         'thesis', 'bull_thesis', 'bear_thesis', 'analysis_summary']
        
        # Add primary content fields first (if they exist)
        for field_name in primary_fields:
            if field_name in data and data[field_name]:
                parts.append(str(data[field_name]))
        
        # Then add other important fields
        for field_name, field_value in data.items():
            if field_name in primary_fields or field_value is None:
                continue
                
            # Format based on type
            if isinstance(field_value, list) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:**")
                for item in field_value:
                    parts.append(f"- {item}")
            elif isinstance(field_value, float):
                # Format percentages nicely
                if 'confidence' in field_name or 'probability' in field_name:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.1%}")
                else:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.2f}")
            elif isinstance(field_value, bool):
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {'Yes' if field_value else 'No'}")
            elif isinstance(field_value, str) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value}")
            elif hasattr(field_value, 'value'):  # Enum
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value.value}")
        
        return "\n".join(parts) if parts else str(data)

class ResearchManagerOutput(BaseModel):
    """Output schema for the Research Manager agent, summarizing research findings and recommendations.

    Used by: research_manager_node, create_research_manager
    """

    summary_bull: str = Field(
        ...,
        description="Summary of bull-side points."
    )
    summary_bear: str = Field(
        ...,
        description="Summary of bear-side points."
    )
    recommendation: TradeDecision = Field(
        ...,
        description="Decisive stance (BUY/SELL/HOLD)."
    )
    confidence: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Confidence in this recommendation (0.0-1.0)"
    )
    quality_score: Optional[float] = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="Quality assessment of the analysis (0.0-1.0)"
    )
    risk_level: float = Field(
        default=None,
        description="Risk level assessment (0.0-1.0, where 1.0 is highest risk)"
    )

    @property
    def content(self) -> str:
        """Convert structured output to content string for backward compatibility.
        
        This property allows existing code that accesses .content to work
        seamlessly with structured output.
        """
        return self.to_content()
    
    def to_message(self):
        """Convert to LangChain AIMessage for message list compatibility.
        
        Returns:
            AIMessage with formatted content, or self if langchain not available.
        """
        if _HAS_LANGCHAIN:
            return AIMessage(content=self.to_content())
        return self
    
    def to_content(self) -> str:
        """Convert the structured output to a formatted string.
        
        Returns:
            A formatted string representation suitable for messages and logs.
        """
        # Smart formatting based on field types and names
        parts = []
        data = self.model_dump()
        
        # Look for common "main content" fields first
        primary_fields = ['summary', 'rationale', 'content', 'report', 'report_markdown', 
                         'thesis', 'bull_thesis', 'bear_thesis', 'analysis_summary']
        
        # Add primary content fields first (if they exist)
        for field_name in primary_fields:
            if field_name in data and data[field_name]:
                parts.append(str(data[field_name]))
        
        # Then add other important fields
        for field_name, field_value in data.items():
            if field_name in primary_fields or field_value is None:
                continue
                
            # Format based on type
            if isinstance(field_value, list) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:**")
                for item in field_value:
                    parts.append(f"- {item}")
            elif isinstance(field_value, float):
                # Format percentages nicely
                if 'confidence' in field_name or 'probability' in field_name:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.1%}")
                else:
                    parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value:.2f}")
            elif isinstance(field_value, bool):
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {'Yes' if field_value else 'No'}")
            elif isinstance(field_value, str) and field_value:
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value}")
            elif hasattr(field_value, 'value'):  # Enum
                parts.append(f"\n**{field_name.replace('_', ' ').title()}:** {field_value.value}")
        
        return "\n".join(parts) if parts else str(data)

