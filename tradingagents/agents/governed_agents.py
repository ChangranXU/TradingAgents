"""ArbiterOS governance layer for trading.

This module provides the ArbiterOS instance and decorator utilities for wrapping
agent node functions with policy-driven governance.

Generated by ArbiterOS Migration Tool.
"""

import functools
import logging
from typing import Any, Callable, TypeVar

from arbiteros_alpha import ArbiterOSAlpha
from arbiteros_alpha.instructions import (
    CognitiveCore,
    ExecutionCore,
    MemoryCore,
    MetacognitiveCore,
    NormativeCore,
)

logger = logging.getLogger(__name__)

# Global ArbiterOS instance for the trading framework
arbiter_os = ArbiterOSAlpha(backend="langgraph")

# Instruction type mappings for different agent roles
TICKER_INITIALIZER_INSTRUCTION = ExecutionCore.TOOL_CALL
METHOD_DECORATOR_INSTRUCTION = MemoryCore.STRUCTURE
BULL_RESEARCHER_INSTRUCTION = CognitiveCore.REFLECT
BEAR_RESEARCHER_INSTRUCTION = CognitiveCore.REFLECT
SAFE_DEBATOR_INSTRUCTION = MetacognitiveCore.EVALUATE_PROGRESS
NEUTRAL_DEBATOR_INSTRUCTION = MetacognitiveCore.EVALUATE_PROGRESS
RISKY_DEBATOR_INSTRUCTION = MetacognitiveCore.EVALUATE_PROGRESS
TRADER_INSTRUCTION = ExecutionCore.TOOL_CALL
RISK_MANAGER_INSTRUCTION = NormativeCore.CONSTRAIN
RESEARCH_MANAGER_INSTRUCTION = ExecutionCore.DELEGATE
MSG_DELETE_INSTRUCTION = MemoryCore.FILTER
MARKET_ANALYST_INSTRUCTION = CognitiveCore.GENERATE
SOCIAL_MEDIA_ANALYST_INSTRUCTION = CognitiveCore.GENERATE
NEWS_ANALYST_INSTRUCTION = CognitiveCore.GENERATE
FUNDAMENTALS_ANALYST_INSTRUCTION = CognitiveCore.GENERATE

# Type variable for function decoration
F = TypeVar("F", bound=Callable[..., Any])


def govern_ticker_initializer(func: F) -> F:
    """Decorator wrapper for ticker_initializer functions.

    Applies TOOL_CALL instruction type governance to functions
    that The function 'init_ticker' is a decorator that initializes an external tool (yf.Ticker) and passes it to the function. This aligns with the TOOL_CALL instruction type, which involves executing predefined external functions..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(TICKER_INITIALIZER_INSTRUCTION)(func)


def govern_method_decorator(func: F) -> F:
    """Decorator wrapper for method_decorator functions.

    Applies STRUCTURE instruction type governance to functions
    that The 'decorate_all_methods' function applies a decorator to all methods of a class, effectively structuring the class's behavior. This aligns with the STRUCTURE instruction type, which involves transforming unstructured text into a structured format..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(METHOD_DECORATOR_INSTRUCTION)(func)


def govern_bull_researcher(func: F) -> F:
    """Decorator wrapper for bull_researcher functions.

    Applies REFLECT instruction type governance to functions
    that The 'create_bull_researcher' function is designed to generate a bull analyst node that reflects on market data to build a strong, evidence-based case. This aligns with the REFLECT instruction type, which involves self-assessment and quality improvement..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(BULL_RESEARCHER_INSTRUCTION)(func)


def govern_bear_researcher(func: F) -> F:
    """Decorator wrapper for bear_researcher functions.

    Applies REFLECT instruction type governance to functions
    that The 'create_bear_researcher' function generates a bear analyst node that reflects on market data to present a well-reasoned argument against investing. This aligns with the REFLECT instruction type, focusing on self-assessment and quality improvement..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(BEAR_RESEARCHER_INSTRUCTION)(func)


def govern_safe_debator(func: F) -> F:
    """Decorator wrapper for safe_debator functions.

    Applies EVALUATE_PROGRESS instruction type governance to functions
    that The 'create_safe_debator' function generates a node that evaluates the trader's decision from a conservative risk perspective, focusing on minimizing volatility and ensuring steady growth. This aligns with the EVALUATE_PROGRESS instruction type, which involves strategic assessment of reasoning path viability..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(SAFE_DEBATOR_INSTRUCTION)(func)


def govern_neutral_debator(func: F) -> F:
    """Decorator wrapper for neutral_debator functions.

    Applies EVALUATE_PROGRESS instruction type governance to functions
    that The 'create_neutral_debator' function generates a node that evaluates the trader's decision from a balanced risk perspective, weighing both potential benefits and risks. This aligns with the EVALUATE_PROGRESS instruction type, focusing on strategic assessment of reasoning path viability..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(NEUTRAL_DEBATOR_INSTRUCTION)(func)


def govern_risky_debator(func: F) -> F:
    """Decorator wrapper for risky_debator functions.

    Applies EVALUATE_PROGRESS instruction type governance to functions
    that The 'create_risky_debator' function generates a node that evaluates the trader's decision from a high-risk perspective, emphasizing bold strategies and potential upsides. This aligns with the EVALUATE_PROGRESS instruction type, focusing on strategic assessment of reasoning path viability..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(RISKY_DEBATOR_INSTRUCTION)(func)


def govern_trader(func: F) -> F:
    """Decorator wrapper for trader functions.

    Applies TOOL_CALL instruction type governance to functions
    that The 'create_trader' function generates a trader node that analyzes market data and makes investment decisions, effectively executing predefined trading strategies. This aligns with the TOOL_CALL instruction type, which involves executing external functions..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(TRADER_INSTRUCTION)(func)


def govern_risk_manager(func: F) -> F:
    """Decorator wrapper for risk_manager functions.

    Applies CONSTRAIN instruction type governance to functions
    that The 'create_risk_manager' function generates a node that evaluates risk debates and determines the best course of action, ensuring compliance with risk management guidelines. This aligns with the CONSTRAIN instruction type, which involves policy compliance enforcement..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(RISK_MANAGER_INSTRUCTION)(func)


def govern_research_manager(func: F) -> F:
    """Decorator wrapper for research_manager functions.

    Applies DELEGATE instruction type governance to functions
    that The 'create_research_manager' function generates a node that oversees the research process and integrates findings, effectively delegating tasks to specialized agents. This aligns with the DELEGATE instruction type, which involves passing sub-tasks to specialized agents..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(RESEARCH_MANAGER_INSTRUCTION)(func)


def govern_msg_delete(func: F) -> F:
    """Decorator wrapper for msg_delete functions.

    Applies FILTER instruction type governance to functions
    that The 'create_msg_delete' function generates a node that clears messages and adds a placeholder, effectively filtering out unnecessary information. This aligns with the FILTER instruction type, which involves selectively pruning context to keep only relevant information..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(MSG_DELETE_INSTRUCTION)(func)


def govern_market_analyst(func: F) -> F:
    """Decorator wrapper for market_analyst functions.

    Applies GENERATE instruction type governance to functions
    that The 'create_market_analyst' function generates a node that analyzes financial markets and selects relevant indicators, effectively generating insights for trading strategies. This aligns with the GENERATE instruction type, which involves content generation and reasoning..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(MARKET_ANALYST_INSTRUCTION)(func)


def govern_social_media_analyst(func: F) -> F:
    """Decorator wrapper for social_media_analyst functions.

    Applies GENERATE instruction type governance to functions
    that The 'create_social_media_analyst' function generates a node that analyzes social media posts and sentiment, generating comprehensive reports for traders. This aligns with the GENERATE instruction type, which involves content generation and reasoning..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(SOCIAL_MEDIA_ANALYST_INSTRUCTION)(func)


def govern_news_analyst(func: F) -> F:
    """Decorator wrapper for news_analyst functions.

    Applies GENERATE instruction type governance to functions
    that The 'create_news_analyst' function generates a node that analyzes recent news and trends, generating comprehensive reports for trading decisions. This aligns with the GENERATE instruction type, which involves content generation and reasoning..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(NEWS_ANALYST_INSTRUCTION)(func)


def govern_fundamentals_analyst(func: F) -> F:
    """Decorator wrapper for fundamentals_analyst functions.

    Applies GENERATE instruction type governance to functions
    that The 'create_fundamentals_analyst' function generates a node that analyzes fundamental information about a company, generating detailed reports for traders. This aligns with the GENERATE instruction type, which involves content generation and reasoning..

    Args:
        func: The node function to wrap.

    Returns:
        The wrapped function with ArbiterOS governance.
    """
    return arbiter_os.instruction(FUNDAMENTALS_ANALYST_INSTRUCTION)(func)


def wrap_factory_result(wrapper_func: Callable[[F], F]) -> Callable:
    """Higher-order decorator for wrapping factory function results.

    This decorator is used to wrap the inner function returned by agent
    factory functions without modifying the factory function itself.

    Args:
        wrapper_func: The governance wrapper to apply.

    Returns:
        A decorator that wraps the result of the factory function.

    Example:
        >>> @wrap_factory_result(govern_analyst)
        ... def create_analyst(llm):
        ...     def analyst_node(state):
        ...         return {"report": "..."}
        ...     return analyst_node
    """

    def factory_decorator(factory_func: Callable) -> Callable:
        @functools.wraps(factory_func)
        def wrapper(*args, **kwargs):
            # Call the original factory to get the node function
            node_func = factory_func(*args, **kwargs)
            # Wrap the node function with governance
            governed_func = wrapper_func(node_func)
            return governed_func

        return wrapper

    return factory_decorator


def get_arbiter_os() -> ArbiterOSAlpha:
    """Get the global ArbiterOS instance.

    Returns:
        The configured ArbiterOSAlpha instance.
    """
    return arbiter_os


def reset_arbiter_os() -> None:
    """Reset the global ArbiterOS instance.

    Creates a new ArbiterOS instance, clearing all history and policies.
    Useful for testing or when starting fresh executions.
    """
    global arbiter_os
    arbiter_os = ArbiterOSAlpha(backend="langgraph")
    logger.info("ArbiterOS instance reset")